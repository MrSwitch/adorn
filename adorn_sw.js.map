{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/adorn_sw.js","webpack:///./src/lib/indexdb.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA,oCAAoC;AACpC,GAAG;;AAEH;AACA;;AAEA;;AAEA,EAAE;;AAEF,CAAC;;;AAGD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA,EAAE;AACF,CAAC,E;;;;;;;;;;;AC/JD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,GAAG;AACH;AACA;;AAEA","file":"adorn_sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/adorn_sw.js\");\n","// Service Worker\n// Caches pages visited by agent for viewing offline\n\nconst CACHE_NAME = 'adorn_sw';\nconst VERSION = 1;\n\nconst DB = require('./lib/indexdb');\nconst db = new DB('adorn_sw', VERSION, {\n\tfalloverStore: {\n\t\tautoIncrement: true\n\t}\n});\n\nconst falloverStore = db('falloverStore');\n\nself.addEventListener('install', event => {\n\t// Perform install steps\n\tevent.waitUntil(\n\t\tcaches.open(CACHE_NAME).then(() => {\n\t\t\t// Opened cache\n\t\t})\n\t);\n});\n\nself.addEventListener('fetch', event => {\n\tconst request = event.request;\n\tlet status;\n\tevent.respondWith((async () => {\n\t\tconst fromCache = caches.match(request)\n\t\t\t.then(b => {\n\t\t\t\tif (b) {\n\t\t\t\t\tstatus = status || 'cache wins';\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t});\n\n\t\tconst fromFetch = fetch(request)\n\t\t\t.then(b => {\n\t\t\t\tif (b) {\n\t\t\t\t\tstatus = status || 'network wins';\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t});\n\n\t\tconst promise = promiseAny([fromCache, fromFetch]);\n\n\t\tpromise.then(() => {\n\t\t\t// Report the success\n\t\t\tconsole.log(status, request.url); // eslint-disable-line no-console\n\t\t});\n\n\t\t// Save\n\t\tfromFetch.then(cacheUpdate.bind(null, request));\n\n\t\treturn promise.catch(offlineFallback.bind(null, request));\n\n\t})());\n\n});\n\n\n// https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/\n\nfunction promiseAny(promises) {\n\treturn new Promise((resolve, reject) => {\n\t\t// make sure promises are all promises\n\t\tpromises = promises.map(p => Promise.resolve(p).then(emptyHandler));\n\t\t// resolve this promise as soon as one resolves\n\t\tpromises.forEach(p => p.then(resolve));\n\t\t// reject if all promises reject\n\t\tpromises\n\t\t\t.reduce((a, b) => a.catch(() => b))\n\t\t\t.catch(() => reject(Error('All failed')));\n\t});\n}\n\n\nfunction emptyHandler(r) {\n\tif (!r) {\n\t\tthrow 'not found';\n\t}\n\treturn r;\n}\n\nfunction cacheUpdate(request, response) {\n\n\t// Check if we received a valid response\n\tif (!response || response.status !== 200 || response.type !== 'basic') {\n\t\treturn response;\n\t}\n\n\tconst responseToCache = response.clone();\n\n\tcaches.open(CACHE_NAME).then(cache => {\n\n\t\t// Replace Cache file\n\t\tcache.put(request, responseToCache);\n\t});\n\n\treturn response;\n}\n\nasync function offlineFallback(request) {\n\n\tconst fallover = await falloverStore.all();\n\n\tconst match = fallover.filter(item => (\n\t\t(!item.mode || item.mode === request.mode)\n\t\t&& (!item.url || request.url.match(item.url))\n\t))[0];\n\n\tif (match) {\n\t\treturn caches.match(new Request(match.fallover));\n\t}\n\n\treturn;\n}\n\n\nself.addEventListener('message', event => {\n\n\tconst data = event.data;\n\n\t// Open cache for actions\n\tcaches.open(CACHE_NAME).then(cache => {\n\t\tswitch (data.type) {\n\n\t\t\tcase 'fallover': {\n\t\t\t\t// Has this already been added?\n\t\t\t\tfalloverStore.all().then(fallover => {\n\t\t\t\t\tconst match = fallover.filter(item => item.mode === data.mode && item.url === data.url)[0];\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// does this need\n\t\t\t\t\t\tif (match.fallover === data.fallover) {\n\t\t\t\t\t\t\t// nothing to do\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst frequest = new Request(data.fallover, {mode: 'no-cors'});\n\n\t\t\t\t\tfetch(frequest).then(response => {\n\t\t\t\t\t\t// Just update the existing record\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tmatch.fallover = data.fallover;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfalloverStore.put(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn cache.put(data.fallover, response);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'add': {\n\t\t\t\tconst request = new Request(data.url, {mode: 'no-cors'});\n\t\t\t\treturn fetch(request).then(response => cache.put(data.url, response));\n\t\t\t}\n\t\t}\n\t});\n});","// indexStorage\n// This wraps an interface around IndexDB to create an object store\n\n// Create an instance of the db\n// The Cache name is optional, it will allow us to group various datasets (the default is __tricks__)\n\nclass DB {\n\tconstructor (name, version, schema) {\n\n\t\t// Define the schema to use in the connection\n\t\tthis.db_name = name || '__adorn__';\n\t\tif (typeof version === 'object') {\n\t\t\tthis.version = 1;\n\t\t\tthis.schema = version;\n\t\t}\n\t\telse {\n\t\t\tthis.version = version || 1;\n\t\t\tthis.schema = schema;\n\t\t}\n\t\tthis.table_name = '__adorn__';\n\n\t\t// Return a function\n\t\treturn Object.assign(this.scope.bind(this), this);\n\t}\n\n\tscope (name) {\n\t\t// Create a new store instance\n\t\tconst inst = Object.create(this);\n\t\tinst.table_name = name;\n\t\treturn inst;\n\t}\n\n\topen(mode) {\n\t\treturn new Promise((accept, reject) => {\n\t\t\tconst db = self.indexedDB.open(this.db_name, this.version);\n\t\t\tdb.onsuccess = event => {\n\t\t\t\taccept(event.target.result);\n\t\t\t};\n\t\t\tdb.onerror = reject;\n\t\t\tdb.onupgradeneeded = event => {\n\t\t\t\tconst db = event.target.result;\n\n\t\t\t\t// this should probably do something;\n\t\t\t\tfor (const x in this.schema) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(x)) {\n\t\t\t\t\t\tdb.createObjectStore(x, this.schema[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t\t\t.then(db => {\n\t\t\t// The DB connection has been established\n\t\t\t// Lets create a connection to it\n\t\t\t\tconst transaction = db.transaction([this.table_name], mode);\n\n\t\t\t\t// Return the API for the Object Store\n\t\t\t\treturn transaction.objectStore(this.table_name);\n\t\t\t});\n\t}\n\n\tget (key) {\n\n\t\t// We've got all the information to make a request to IndexDB\n\t\treturn new Promise((accept, reject) => {\n\t\t\tthis.open().then(objectStore => {\n\t\t\t\t// Find items in this table by Key\n\t\t\t\tconst request = objectStore.get(key);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\taccept(event.target.result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tall () {\n\n\t\t// We've got all the information to make a request to IndexDB\n\t\treturn new Promise((accept, reject) => {\n\t\t\tthis.open().then(objectStore => {\n\t\t\t\t// Find items in this table by Key\n\t\t\t\tconst request = objectStore.openCursor();\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\n\t\t\t\tconst a = [];\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\tconst cursor = event.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\ta.push(cursor.value);\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taccept(a);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tput (key, data) {\n\n\t\treturn new Promise((accept, reject) => {\n\n\t\t\t// Allow data as a thing on its own.\n\t\t\tif (typeof key === 'object') {\n\t\t\t\tdata = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.key = key;\n\t\t\t}\n\n\t\t\t// Open up a connection to indexdb\n\t\t\tthis.open('readwrite').then(objectStore => {\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\taccept(event.target.result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\t\t\t})\n\t\t\t\t.catch(reject);\n\n\t\t});\n\t}\n}\n\nmodule.exports = DB;\n"],"sourceRoot":""}