{
  "version": 3,
  "sources": ["src/lib/indexdb.js", "src/adorn_sw.js"],
  "sourcesContent": ["// indexStorage\n// This wraps an interface around IndexDB to create an object store\n\n// Create an instance of the db\n// The Cache name is optional, it will allow us to group various datasets (the default is __tricks__)\n\nexport class DB {\n\tconstructor(name, version, schema) {\n\n\t\t// Define the schema to use in the connection\n\t\tthis.db_name = name || '__adorn__';\n\t\tif (typeof version === 'object') {\n\t\t\tthis.version = 1;\n\t\t\tthis.schema = version;\n\t\t}\n\t\telse {\n\t\t\tthis.version = version || 1;\n\t\t\tthis.schema = schema;\n\t\t}\n\t\tthis.table_name = '__adorn__';\n\n\t\t// Return a function\n\t\treturn Object.assign(this.scope.bind(this), this);\n\t}\n\n\tscope(name) {\n\t\t// Create a new store instance\n\t\tconst inst = Object.create(this);\n\t\tinst.table_name = name;\n\t\treturn inst;\n\t}\n\n\topen(mode) {\n\t\treturn new Promise((accept, reject) => {\n\t\t\tconst db = self.indexedDB.open(this.db_name, this.version);\n\t\t\tdb.onsuccess = event => {\n\t\t\t\taccept(event.target.result);\n\t\t\t};\n\t\t\tdb.onerror = reject;\n\t\t\tdb.onupgradeneeded = event => {\n\t\t\t\tconst db = event.target.result;\n\n\t\t\t\t// this should probably do something;\n\t\t\t\tfor (const x in this.schema) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(x)) {\n\t\t\t\t\t\tdb.createObjectStore(x, this.schema[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t\t\t.then(db => {\n\t\t\t// The DB connection has been established\n\t\t\t// Lets create a connection to it\n\t\t\t\tconst transaction = db.transaction([this.table_name], mode);\n\n\t\t\t\t// Return the API for the Object Store\n\t\t\t\treturn transaction.objectStore(this.table_name);\n\t\t\t});\n\t}\n\n\tget(key) {\n\n\t\t// We've got all the information to make a request to IndexDB\n\t\treturn new Promise((accept, reject) => {\n\t\t\tthis.open().then(objectStore => {\n\t\t\t\t// Find items in this table by Key\n\t\t\t\tconst request = objectStore.get(key);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\taccept(event.target.result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tall() {\n\n\t\t// We've got all the information to make a request to IndexDB\n\t\treturn new Promise((accept, reject) => {\n\t\t\tthis.open().then(objectStore => {\n\t\t\t\t// Find items in this table by Key\n\t\t\t\tconst request = objectStore.openCursor();\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\n\t\t\t\tconst a = [];\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\tconst cursor = event.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\ta.push(cursor.value);\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taccept(a);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tput(key, data) {\n\n\t\treturn new Promise((accept, reject) => {\n\n\t\t\t// Allow data as a thing on its own.\n\t\t\tif (typeof key === 'object') {\n\t\t\t\tdata = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.key = key;\n\t\t\t}\n\n\t\t\t// Open up a connection to indexdb\n\t\t\tthis.open('readwrite').then(objectStore => {\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\taccept(event.target.result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\t\t\t})\n\t\t\t\t.catch(reject);\n\n\t\t});\n\t}\n}\n", "// Service Worker\n// Caches pages visited by agent for viewing offline\n\nconst CACHE_NAME = 'adorn_sw';\nconst VERSION = 1;\n\nconst DB = require('./lib/indexdb');\nconst db = new DB('adorn_sw', VERSION, {\n\tfalloverStore: {\n\t\tautoIncrement: true\n\t}\n});\n\nconst falloverStore = db('falloverStore');\n\nself.addEventListener('install', event => {\n\t// Perform install steps\n\tevent.waitUntil(\n\t\tcaches.open(CACHE_NAME).then(() => {\n\t\t\t// Opened cache\n\t\t})\n\t);\n});\n\nself.addEventListener('fetch', event => {\n\n\t{\n\t\tconst target = new URL(event.request.url);\n\t\t// Only handle requests which belong to the current host.\n\t\tif (self.location.host !== target.host) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tconst request = event.request;\n\tlet status;\n\tevent.respondWith((async () => {\n\t\tconst fromCache = caches.match(request)\n\t\t\t.then(b => {\n\t\t\t\tif (b) {\n\t\t\t\t\tstatus = status || 'cache wins';\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t});\n\n\t\tconst fromFetch = fetch(request)\n\t\t\t.then(b => {\n\t\t\t\tif (b) {\n\t\t\t\t\tstatus = status || 'network wins';\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t});\n\n\t\tconst promise = promiseAny([fromCache, fromFetch]);\n\n\t\tpromise.then(() => {\n\t\t\t// Report the success\n\t\t\tconsole.log(status, request.url); // eslint-disable-line no-console\n\t\t});\n\n\t\t// Save\n\t\tfromFetch.then(cacheUpdate.bind(null, request));\n\n\t\treturn promise.catch(offlineFallback.bind(null, request));\n\n\t})());\n\n});\n\n\n// https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/\n\nfunction promiseAny(promises) {\n\treturn new Promise((resolve, reject) => {\n\t\t// make sure promises are all promises\n\t\tpromises = promises.map(p => Promise.resolve(p).then(emptyHandler));\n\t\t// resolve this promise as soon as one resolves\n\t\tpromises.forEach(p => p.then(resolve));\n\t\t// reject if all promises reject\n\t\tpromises\n\t\t\t.reduce((a, b) => a.catch(() => b))\n\t\t\t.catch(() => reject(Error('All failed')));\n\t});\n}\n\n\nfunction emptyHandler(r) {\n\tif (!r) {\n\t\tthrow new Error('not found');\n\t}\n\treturn r;\n}\n\nfunction cacheUpdate(request, response) {\n\n\t// Check if we received a valid response\n\tif (!response || response.status !== 200 || response.type !== 'basic') {\n\t\treturn response;\n\t}\n\n\tconst responseToCache = response.clone();\n\n\tcaches.open(CACHE_NAME).then(cache => {\n\n\t\t// Replace Cache file\n\t\tcache.put(request, responseToCache);\n\t});\n\n\treturn response;\n}\n\nasync function offlineFallback(request) {\n\n\tconst fallover = await falloverStore.all();\n\n\tconst match = fallover.filter(item => (\n\t\t(!item.mode || item.mode === request.mode)\n\t\t&& (!item.url || request.url.match(item.url))\n\t))[0];\n\n\tif (match) {\n\t\treturn caches.match(new Request(match.fallover));\n\t}\n\n\n}\n\n\nself.addEventListener('message', event => {\n\n\tconst data = event.data;\n\n\t// Open cache for actions\n\tcaches.open(CACHE_NAME).then(cache => {\n\t\tswitch (data.type) {\n\n\t\t\tcase 'fallover': {\n\t\t\t\t// Has this already been added?\n\t\t\t\tfalloverStore.all().then(fallover => {\n\t\t\t\t\tconst match = fallover.filter(item => item.mode === data.mode && item.url === data.url)[0];\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// does this need\n\t\t\t\t\t\tif (match.fallover === data.fallover) {\n\t\t\t\t\t\t\t// nothing to do\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst frequest = new Request(data.fallover, {mode: 'no-cors'});\n\n\t\t\t\t\tfetch(frequest).then(response => {\n\t\t\t\t\t\t// Just update the existing record\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tmatch.fallover = data.fallover;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfalloverStore.put(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn cache.put(data.fallover, response);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'add': {\n\t\t\t\tconst request = new Request(data.url, {mode: 'no-cors'});\n\t\t\t\treturn fetch(request).then(response => cache.put(data.url, response));\n\t\t\t}\n\t\t}\n\t});\n});"],
  "mappings": "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",
  "names": ["indexdb_exports", "__export", "DB", "init_indexdb", "__esmMin", "name", "version", "schema", "inst", "mode", "accept", "reject", "db", "event", "x", "key", "objectStore", "request", "a", "cursor", "data", "CACHE_NAME", "DB", "db", "falloverStore", "event", "CACHE_NAME", "target", "request", "status", "fromCache", "b", "fromFetch", "promise", "promiseAny", "cacheUpdate", "offlineFallback", "promises", "resolve", "reject", "p", "emptyHandler", "a", "response", "responseToCache", "cache", "match", "item", "data", "fallover", "frequest"]
}
