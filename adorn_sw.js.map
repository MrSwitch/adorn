{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lib/indexdb.js","webpack:///./src/adorn_sw.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","e","t","[object Object]","version","schema","this","db_name","table_name","assign","scope","bind","inst","create","mode","Promise","accept","reject","db","self","indexedDB","open","onsuccess","event","target","result","onerror","onupgradeneeded","x","objectStoreNames","contains","createObjectStore","then","transaction","objectStore","key","request","openCursor","a","cursor","push","continue","data","put","catch","falloverStore","autoIncrement","promises","emptyHandler","addEventListener","waitUntil","caches","status","respondWith","fromCache","match","b","fromFetch","fetch","promise","resolve","map","forEach","reduce","Error","console","log","url","response","type","responseToCache","clone","cache","async","all","filter","item","Request","fallover","frequest"],"mappings":"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","file":"adorn_sw.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// indexStorage\n// This wraps an interface around IndexDB to create an object store\n\n// Create an instance of the db\n// The Cache name is optional, it will allow us to group various datasets (the default is __tricks__)\n\nclass DB {\n\tconstructor (name, version, schema) {\n\n\t\t// Define the schema to use in the connection\n\t\tthis.db_name = name || '__adorn__';\n\t\tif (typeof version === 'object') {\n\t\t\tthis.version = 1;\n\t\t\tthis.schema = version;\n\t\t}\n\t\telse {\n\t\t\tthis.version = version || 1;\n\t\t\tthis.schema = schema;\n\t\t}\n\t\tthis.table_name = '__adorn__';\n\n\t\t// Return a function\n\t\treturn Object.assign(this.scope.bind(this), this);\n\t}\n\n\tscope (name) {\n\t\t// Create a new store instance\n\t\tconst inst = Object.create(this);\n\t\tinst.table_name = name;\n\t\treturn inst;\n\t}\n\n\topen(mode) {\n\t\treturn new Promise((accept, reject) => {\n\t\t\tconst db = self.indexedDB.open(this.db_name, this.version);\n\t\t\tdb.onsuccess = event => {\n\t\t\t\taccept(event.target.result);\n\t\t\t};\n\t\t\tdb.onerror = reject;\n\t\t\tdb.onupgradeneeded = event => {\n\t\t\t\tconst db = event.target.result;\n\n\t\t\t\t// this should probably do something;\n\t\t\t\tfor (const x in this.schema) {\n\t\t\t\t\tif (!db.objectStoreNames.contains(x)) {\n\t\t\t\t\t\tdb.createObjectStore(x, this.schema[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})\n\t\t\t.then(db => {\n\t\t\t// The DB connection has been established\n\t\t\t// Lets create a connection to it\n\t\t\t\tconst transaction = db.transaction([this.table_name], mode);\n\n\t\t\t\t// Return the API for the Object Store\n\t\t\t\treturn transaction.objectStore(this.table_name);\n\t\t\t});\n\t}\n\n\tget (key) {\n\n\t\t// We've got all the information to make a request to IndexDB\n\t\treturn new Promise((accept, reject) => {\n\t\t\tthis.open().then(objectStore => {\n\t\t\t\t// Find items in this table by Key\n\t\t\t\tconst request = objectStore.get(key);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\taccept(event.target.result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tall () {\n\n\t\t// We've got all the information to make a request to IndexDB\n\t\treturn new Promise((accept, reject) => {\n\t\t\tthis.open().then(objectStore => {\n\t\t\t\t// Find items in this table by Key\n\t\t\t\tconst request = objectStore.openCursor();\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\n\t\t\t\tconst a = [];\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\tconst cursor = event.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\ta.push(cursor.value);\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\taccept(a);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tput (key, data) {\n\n\t\treturn new Promise((accept, reject) => {\n\n\t\t\t// Allow data as a thing on its own.\n\t\t\tif (typeof key === 'object') {\n\t\t\t\tdata = key;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.key = key;\n\t\t\t}\n\n\t\t\t// Open up a connection to indexdb\n\t\t\tthis.open('readwrite').then(objectStore => {\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\taccept(event.target.result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = event => {\n\t\t\t\t\treject(event.target.result);\n\t\t\t\t};\n\t\t\t})\n\t\t\t\t.catch(reject);\n\n\t\t});\n\t}\n}\n\nmodule.exports = DB;\n","// Service Worker\n// Caches pages visited by agent for viewing offline\n\nconst CACHE_NAME = 'adorn_sw';\nconst VERSION = 1;\n\nconst DB = require('./lib/indexdb');\nconst db = new DB('adorn_sw', VERSION, {\n\tfalloverStore: {\n\t\tautoIncrement: true\n\t}\n});\n\nconst falloverStore = db('falloverStore');\n\nself.addEventListener('install', event => {\n\t// Perform install steps\n\tevent.waitUntil(\n\t\tcaches.open(CACHE_NAME).then(() => {\n\t\t\t// Opened cache\n\t\t})\n\t);\n});\n\nself.addEventListener('fetch', event => {\n\tconst request = event.request;\n\tlet status;\n\tevent.respondWith((async () => {\n\t\tconst fromCache = caches.match(request)\n\t\t\t.then(b => {\n\t\t\t\tif (b) {\n\t\t\t\t\tstatus = status || 'cache wins';\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t});\n\n\t\tconst fromFetch = fetch(request)\n\t\t\t.then(b => {\n\t\t\t\tif (b) {\n\t\t\t\t\tstatus = status || 'network wins';\n\t\t\t\t}\n\t\t\t\treturn b;\n\t\t\t});\n\n\t\tconst promise = promiseAny([fromCache, fromFetch]);\n\n\t\tpromise.then(() => {\n\t\t\t// Report the success\n\t\t\tconsole.log(status, request.url); // eslint-disable-line no-console\n\t\t});\n\n\t\t// Save\n\t\tfromFetch.then(cacheUpdate.bind(null, request));\n\n\t\treturn promise.catch(offlineFallback.bind(null, request));\n\n\t})());\n\n});\n\n\n// https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/\n\nfunction promiseAny(promises) {\n\treturn new Promise((resolve, reject) => {\n\t\t// make sure promises are all promises\n\t\tpromises = promises.map(p => Promise.resolve(p).then(emptyHandler));\n\t\t// resolve this promise as soon as one resolves\n\t\tpromises.forEach(p => p.then(resolve));\n\t\t// reject if all promises reject\n\t\tpromises\n\t\t\t.reduce((a, b) => a.catch(() => b))\n\t\t\t.catch(() => reject(Error('All failed')));\n\t});\n}\n\n\nfunction emptyHandler(r) {\n\tif (!r) {\n\t\tthrow 'not found';\n\t}\n\treturn r;\n}\n\nfunction cacheUpdate(request, response) {\n\n\t// Check if we received a valid response\n\tif (!response || response.status !== 200 || response.type !== 'basic') {\n\t\treturn response;\n\t}\n\n\tconst responseToCache = response.clone();\n\n\tcaches.open(CACHE_NAME).then(cache => {\n\n\t\t// Replace Cache file\n\t\tcache.put(request, responseToCache);\n\t});\n\n\treturn response;\n}\n\nasync function offlineFallback(request) {\n\n\tconst fallover = await falloverStore.all();\n\n\tconst match = fallover.filter(item => (\n\t\t(!item.mode || item.mode === request.mode)\n\t\t&& (!item.url || request.url.match(item.url))\n\t))[0];\n\n\tif (match) {\n\t\treturn caches.match(new Request(match.fallover));\n\t}\n\n\treturn;\n}\n\n\nself.addEventListener('message', event => {\n\n\tconst data = event.data;\n\n\t// Open cache for actions\n\tcaches.open(CACHE_NAME).then(cache => {\n\t\tswitch (data.type) {\n\n\t\t\tcase 'fallover': {\n\t\t\t\t// Has this already been added?\n\t\t\t\tfalloverStore.all().then(fallover => {\n\t\t\t\t\tconst match = fallover.filter(item => item.mode === data.mode && item.url === data.url)[0];\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// does this need\n\t\t\t\t\t\tif (match.fallover === data.fallover) {\n\t\t\t\t\t\t\t// nothing to do\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst frequest = new Request(data.fallover, {mode: 'no-cors'});\n\n\t\t\t\t\tfetch(frequest).then(response => {\n\t\t\t\t\t\t// Just update the existing record\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tmatch.fallover = data.fallover;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfalloverStore.put(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn cache.put(data.fallover, response);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'add': {\n\t\t\t\tconst request = new Request(data.url, {mode: 'no-cors'});\n\t\t\t\treturn fetch(request).then(response => cache.put(data.url, response));\n\t\t\t}\n\t\t}\n\t});\n});"],"sourceRoot":""}